[{"content":"What is Embedded Insurance? Embedded insurance is a distribution model where insurance is integrated directly into a primary product or transaction journey — rather than sold separately through agents or aggregators.\nReal-world examples:\nDevice protection offered during mobile checkout Loan protection bundled with credit disbursement Travel insurance embedded in ticket booking Health cover attached to a subscription plan Unlike traditional agency or bancassurance models, embedded insurance is:\nPartner-distributed — e-commerce, fintech, NBFC, and travel platforms sell the product API-driven and real-time — no manual underwriting delays SKU-based — sellable units attached to transactions Operated under a Master Policy + Certificate of Insurance (COI) structure Highly automated — across issuance, finance, and claims Key Structural Concepts Before diving into architecture, these domain concepts are essential:\nConcept Definition Master Policy A single contract issued to the partner (or aggregator) covering a defined cohort of customers Certificate of Insurance (COI) Individual proof of coverage issued to each insured under the master policy SKU The smallest sellable unit — a versioned plan with specific covers and pricing rules Cover Risk type (e.g., accidental damage, hospitalization, death) Benefit Payout construct within a cover Underwriting Assumed as a black-box service that returns eligibility and pricing modifiers Part 1 — Platform Architecture Blueprint Product Hierarchy \u0026amp; SKU Design This is the foundation of configurability. The product engine must support multiple lines of business (LOBs) without LOB-specific code.\nProduct └── Plan (Versioned) └── Cover └── Benefit └── Configurations Example SKU:\n{ \u0026#34;sku_id\u0026#34;: \u0026#34;LOAN_PROTECT_V3\u0026#34;, \u0026#34;lob\u0026#34;: \u0026#34;credit_life\u0026#34;, \u0026#34;covers\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;death_cover\u0026#34;, \u0026#34;sum_insured_formula\u0026#34;: \u0026#34;loan_outstanding\u0026#34; } ], \u0026#34;pricing_model\u0026#34;: \u0026#34;grid_v2\u0026#34;, \u0026#34;eligibility_profile\u0026#34;: \u0026#34;loan_basic_rules\u0026#34; } Design Principles:\nVersioning is mandatory. Plans must be immutable once published. Never modify live plans — create a new version, soft-deprecate the old one, and maintain backward compatibility.\nPartner overlays stay separate. Partners may require custom pricing, modified eligibility, or commission overrides. Keep overrides in a separate layer from the base product definition:\nBase Plan + Partner Override Layer Integrations Layer Embedded insurance must support multiple integration modes to serve different partner types.\nAPI-Based (Real-Time) Used by e-commerce, fintech lending, BNPL, and wallet integrations.\nPartner → Proposal API → Eligibility → Pricing → Issuance → COI Design requirements:\nIdempotency keys on every mutating call Versioned APIs Async event notifications (webhooks) Timeout-safe retry logic POS / SDK Integrations Used for offline stores and agent-assisted selling:\nToken-based authentication Embedded UI SDK with local validation + backend confirmation Offline (SFTP / Batch) Used by NBFCs and enterprise partners:\nBatch file upload → Validation pipeline → Pricing + Eligibility → Bulk issuance → Reconciliation report Must include file checksum validation, row-level error reporting, and reprocessing capability Pricing Engine (Grid-Based) Embedded insurance typically uses grid-based pricing rather than actuarial models at runtime.\nExample pricing grid:\nAge Band Loan Tenure Rate 18–40 \u0026lt; 24 months 0.8% 41–60 \u0026lt; 24 months 1.2% 18–40 \u0026gt; 24 months 1.1% Resolution flow:\nPricing Input → Grid Resolver → Rate Selection → Premium Calculator Key considerations:\nGrid versioning (old grids must remain queryable) Partner-level overrides Preloading grids in memory for performance Formula abstraction — no hardcoded logic Eligibility Engine Eligibility rules can be static (mandatory field validation), rule-based (config-driven), or underwriting-triggered (external service).\nExample Rule DSL:\nIF loan_amount \u0026gt; 5L THEN reject IF age \u0026gt; 65 THEN reject IF pincode IN blacklist THEN reject Fail strategy:\nFail-closed — reject if rules are unavailable (preferred for insurance) Fail-open — allow issuance if non-critical (only with explicit approval) Failure Handling Embedded insurance platforms must handle complex failure scenarios gracefully.\nScenario Strategy Payment success, issuance failure Compensation workflow → Retry issuance → If irrecoverable, trigger refund + reversal entry PAS (Policy Admin System) timeout Async confirmation → Track pending_issuance state → Reconcile via event listener Duplicate requests Idempotency keys + unique proposal reference ID + state-based validation Float Balance / Partner Ledger Two common financial models:\nModel How It Works Pre-funded (Float) Partner maintains a balance. Debit float → Issue policy Post-paid Commission Insurer settles commission periodically Float ledger design (high-level):\npartner_wallet: | partner_id | balance | wallet_transactions: | txn_id | partner_id | debit | credit | reference_id | Settlement cycle: Daily premium collection summary → Commission deduction → Net settlement report.\nThe ledger must be immutable.\nCertificate of Insurance (COI) COI lifecycle:\nPolicy Issued → Data bound to template → PDF generated → Stored in object storage → URL returned Design requirements:\nVersioned templates with dynamic placeholders Template audit trail Re-generation capability Must reference: master policy number, certificate number, coverage details Claims System FNOL → Documents Pending → Assessment → Approved / Rejected → Paid Key data points per claim: Claim ID, Policy reference, Reserve amount, Paid amount, Fraud flags.\nReserve vs Paid — Reserve is the expected liability; Paid is the actual settlement. Reserve tracking is critical for regulatory reporting.\nReporting Architecture Embedded insurance must support both regulatory (IRDAI) and partner reporting.\nCore registers:\nRegister Key Fields Premium Register policy_id, premium, tax, net Claims Paid Register claim_id, amount_paid, payout_date Claims Reserve Register claim_id, reserve_amount Commission Register partner_id, commission_amount Architecture:\nOperational DB → Event Stream → Reporting Warehouse → Regulatory / Partner Reports Never run heavy reports on the transactional database.\nIRDAI reporting considerations: Monthly premium summaries, claim ratio reporting, product-wise data segregation, audit-ready exports.\nPart 2 — Domain Model \u0026amp; Entity-Relationship Design This section maps the architecture into a production-grade domain model, organized by bounded context.\nBounded Contexts The platform is organized into 6 isolated contexts:\nProduct Configuration — Product, Plan, Cover, Benefit, SKU Pricing \u0026amp; Eligibility — Grid models, rule definitions Policy \u0026amp; Issuance — Proposal, Underwriting, Policy, Certificate Claims — Claim lifecycle, documents, payments Finance \u0026amp; Ledger — Double-entry accounts, float wallet Partner \u0026amp; Overlay — Partner config, plan overrides Product \u0026amp; SKU Entities product id UUID name string lob string (device / health / credit) status enum (draft / active / deprecated) plan id UUID product_id FK(product) version integer effective_from date effective_to date status enum ← Immutable once active plan_cover id UUID plan_id FK(plan) cover_type string sum_insured_formula string cover_benefit id UUID plan_cover_id FK(plan_cover) benefit_type string payout_logic json sku id UUID plan_id FK(plan) sku_code string pricing_model_id FK(pricing_model) eligibility_profile_id FK(eligibility_profile) SKU is the sellable layer — the unit partners interact with.\nPricing \u0026amp; Eligibility Entities pricing_model id UUID type enum(grid / formula) version integer pricing_grid id UUID pricing_model_id FK param_1 string param_2 string rate decimal eligibility_profile id UUID rule_definition json version integer ← Rules stored as DSL JSON Proposal → Policy Issuance Entities Proposal → Underwriting Decision → Policy → Certificate proposal id UUID partner_id FK(partner) sku_id FK(sku) status enum(draft / submitted / approved / rejected) premium_amount decimal meta json underwriting_decision id UUID proposal_id FK decision enum(approved / rejected / manual) score decimal reason string policy id UUID master_policy_id FK(master_policy) proposal_id FK policy_number string status enum(issued / active / cancelled / expired) start_date date end_date date certificate id UUID policy_id FK certificate_number string pdf_url string template_version integer master_policy id UUID insurer_reference string partner_id FK product_id FK start_date date end_date date Claims Entities Policy → Claim → Claim_Event / Claim_Document / Claim_Payment claim id UUID policy_id FK status enum loss_date date reserve_amount decimal approved_amount decimal claim_event id UUID claim_id FK event_type string created_at timestamp claim_document id UUID claim_id FK doc_type string storage_url string claim_payment id UUID claim_id FK amount decimal payout_date date payment_reference string Finance \u0026amp; Ledger Entities This is the most critical section. Never mix business tables with ledger tables.\nledger_account id UUID account_type enum(premium_receivable, insurer_payable, commission_payable, claims_payable) owner_type enum(system, partner, insurer) owner_id UUID ledger_entry ← IMMUTABLE TABLE id UUID debit_account_id FK credit_account_id FK amount decimal reference_type enum(policy, claim, refund) reference_id UUID created_at timestamp Float wallet:\npartner_wallet partner_id UUID balance decimal wallet_txn id UUID partner_id UUID debit decimal credit decimal reference_id UUID Partner \u0026amp; Overlay Entities partner id UUID name string integration_mode enum(api / pos / batch) partner_plan_override id UUID partner_id FK sku_id FK pricing_override json commission_override decimal Full Platform ER Diagram Below is the complete entity-relationship diagram in Mermaid syntax. You can render it in any Mermaid-compatible tool.\nerDiagram %% ── PARTNER CONTEXT ── PARTNER { UUID id string name string integration_mode } MASTER_POLICY { UUID id UUID partner_id UUID product_id string insurer_reference date start_date date end_date } PARTNER ||--o{ MASTER_POLICY : owns %% ── PRODUCT CONFIGURATION ── PRODUCT { UUID id string name string lob string status } PLAN { UUID id UUID product_id int version date effective_from date effective_to string status } PLAN_COVER { UUID id UUID plan_id string cover_type string sum_insured_formula } COVER_BENEFIT { UUID id UUID plan_cover_id string benefit_type json payout_logic } SKU { UUID id UUID plan_id string sku_code UUID pricing_model_id UUID eligibility_profile_id } PRODUCT ||--o{ PLAN : contains PLAN ||--o{ PLAN_COVER : defines PLAN_COVER ||--o{ COVER_BENEFIT : includes PLAN ||--o{ SKU : sellable_unit %% ── PRICING \u0026amp; ELIGIBILITY ── PRICING_MODEL { UUID id string type int version } PRICING_GRID { UUID id UUID pricing_model_id string param_1 string param_2 decimal rate } ELIGIBILITY_PROFILE { UUID id json rule_definition int version } PRICING_MODEL ||--o{ PRICING_GRID : defines SKU }o--|| PRICING_MODEL : uses SKU }o--|| ELIGIBILITY_PROFILE : validated_by %% ── PROPOSAL \u0026amp; POLICY ── PROPOSAL { UUID id UUID partner_id UUID sku_id string status decimal premium_amount json meta } UNDERWRITING_DECISION { UUID id UUID proposal_id string decision decimal score string reason } POLICY { UUID id UUID master_policy_id UUID proposal_id string policy_number string status date start_date date end_date } CERTIFICATE { UUID id UUID policy_id string certificate_number string pdf_url int template_version } PARTNER ||--o{ PROPOSAL : initiates SKU ||--o{ PROPOSAL : selected_in PROPOSAL ||--|| UNDERWRITING_DECISION : evaluated_by PROPOSAL ||--|| POLICY : converts_to MASTER_POLICY ||--o{ POLICY : governs POLICY ||--|| CERTIFICATE : generates %% ── CLAIMS CONTEXT ── CLAIM { UUID id UUID policy_id string status date loss_date decimal reserve_amount decimal approved_amount } CLAIM_EVENT { UUID id UUID claim_id string event_type datetime created_at } CLAIM_DOCUMENT { UUID id UUID claim_id string doc_type string storage_url } CLAIM_PAYMENT { UUID id UUID claim_id decimal amount date payout_date } POLICY ||--o{ CLAIM : triggers CLAIM ||--o{ CLAIM_EVENT : tracks CLAIM ||--o{ CLAIM_DOCUMENT : attaches CLAIM ||--o{ CLAIM_PAYMENT : settles %% ── FINANCE \u0026amp; LEDGER ── LEDGER_ACCOUNT { UUID id string account_type string owner_type UUID owner_id } LEDGER_ENTRY { UUID id UUID debit_account_id UUID credit_account_id decimal amount string reference_type UUID reference_id datetime created_at } LEDGER_ACCOUNT ||--o{ LEDGER_ENTRY : participates POLICY ||--o{ LEDGER_ENTRY : premium_related CLAIM ||--o{ LEDGER_ENTRY : payout_related %% ── PARTNER FLOAT WALLET ── PARTNER_WALLET { UUID partner_id decimal balance } WALLET_TXN { UUID id UUID partner_id decimal debit decimal credit UUID reference_id } PARTNER ||--|| PARTNER_WALLET : has PARTNER_WALLET ||--o{ WALLET_TXN : records %% ── REPORTING LAYER ── PREMIUM_REGISTER { UUID policy_id decimal premium decimal tax decimal net } CLAIMS_PAID_REGISTER { UUID claim_id decimal amount_paid } CLAIMS_RESERVE_REGISTER { UUID claim_id decimal reserve_amount } COMMISSION_REGISTER { UUID partner_id decimal commission } POLICY ||--o{ PREMIUM_REGISTER : reported_in CLAIM ||--o{ CLAIMS_PAID_REGISTER : reported_in CLAIM ||--o{ CLAIMS_RESERVE_REGISTER : reported_in PARTNER ||--o{ COMMISSION_REGISTER : earns Relationship Summary Partner └── Master_Policy └── Policy └── Certificate └── Claim → Claim_Payment Product └── Plan └── SKU └── Proposal → Policy Policy / Claim → Ledger_Entry Part 3 — End-to-End Issuance Flow This section moves from static design to runtime system behavior. We walk through a complete issuance cycle for a loan protection product using a pre-funded float model.\nScenario: Partner is an NBFC. Product is Loan Protection Insurance. Financial model is pre-funded float. Underwriting is abstracted (assume approval).\nHigh-Level Flow Partner → Proposal API → Eligibility → Pricing → Underwriting ↓ Policy Issuance ↓ Ledger Posting (Premium, Commission, Insurer Payable) ↓ COI Generation ↓ Event Emission ↓ Reporting Pipeline Step 1: Proposal Creation API request:\n{ \u0026#34;partner_id\u0026#34;: \u0026#34;NBFC_X\u0026#34;, \u0026#34;sku_id\u0026#34;: \u0026#34;LOAN_PROTECT_V3\u0026#34;, \u0026#34;insured\u0026#34;: { \u0026#34;loan_amount\u0026#34;: 500000, \u0026#34;tenure\u0026#34;: 36, \u0026#34;age\u0026#34;: 32 }, \u0026#34;idempotency_key\u0026#34;: \u0026#34;loan_12345\u0026#34; } System actions:\nValidate partner Fetch SKU + plan version Run eligibility rules Resolve pricing grid Call underwriting engine (abstracted) Persist proposal Database writes:\nTable id status premium proposal P1 approved 4500 Table proposal_id decision underwriting_decision P1 approved Step 2: Policy Issuance Issuance must be idempotent. Issuance and ledger posting must occur in a single atomic transaction or with event-sourced compensation.\nDatabase writes:\nTable id proposal_id status policy POL1 P1 issued Table id policy_id certificate_no certificate C1 POL1 CERT_123 Step 3: Ledger Posting (Financial Core) This is where most naive systems fail.\nAssume: Premium = 4500, Commission = 900, Insurer share = 3600.\nLedger accounts involved:\nAccount Owner Premium Receivable System Insurer Payable Insurer Partner Commission Payable Partner Partner Float Wallet Partner Journal entries (double-entry):\nEntry 1 — Deduct float:\nDebit: Partner Float Wallet 4500 Credit: Premium Receivable 4500 Entry 2 — Allocate premium to insurer:\nDebit: Premium Receivable 4500 Credit: Insurer Payable 3600 Credit: Partner Commission Payable 900 All entries are stored in ledger_entry — immutable, append-only.\nStep 4: COI Generation Load template version Bind policy + insured data Generate PDF Store in object storage Update certificate record with pdf_url Step 5: Emit Domain Events { \u0026#34;event_type\u0026#34;: \u0026#34;policy_issued\u0026#34;, \u0026#34;policy_id\u0026#34;: \u0026#34;POL1\u0026#34;, \u0026#34;premium\u0026#34;: 4500, \u0026#34;commission\u0026#34;: 900 } Event bus consumers:\nReporting pipeline Settlement service Partner webhook notification Reporting Pipeline Operational DB → CDC / Event Stream → Reporting Warehouse → IRDAI Reports / Partner Dashboards Registers generated from this issuance:\nRegister Key Data Premium Register POL1, gross: 4500, tax: 0, net: 4500 Commission Register NBFC_X, POL1, commission: 900 Insurer Payable Report InsurerA, total: 3600 Float Balance Snapshot NBFC_X, balance: old - 4500 Settlement Cycle (T+1) At settlement time:\nDebit: Insurer Payable 3600 Credit: Bank Settlement Account 3600 Debit: Partner Commission Payable 900 Credit: Partner Bank Account 900 Claims Impact on Ledger When claim is approved (reserve created):\nDebit: Claims Expense Credit: Claims Reserve When claim is paid:\nDebit: Claims Reserve Credit: Bank Account Reserve tracking feeds IRDAI reporting directly.\nPart 4 — Failure Scenarios \u0026amp; Recovery Scenario A: Policy Created, Ledger Fails Wrap issuance + ledger in a DB transaction, or use an event-driven compensation workflow.\nIf ledger posting fails:\nMark policy as issuance_pending Retry ledger posting Never leave a policy in issued state without corresponding ledger entries Scenario B: Ledger Posted, COI Fails Non-financial failure. Retry COI generation independently. Never reverse ledger entries for a document generation failure.\nScenario C: Float Insufficient Pre-check before issuance:\nIF float_balance \u0026lt; premium THEN reject Or move the partner to a credit-based model.\nScenario D: Reporting Lag Reporting must be eventually consistent. Never block issuance for a reporting write.\nPart 5 — Reconciliation \u0026amp; Data Consistency Daily Reconciliation Jobs Compare across systems:\nLedger premium total vs. float deductions Float deductions vs. insurer payable Insurer payable vs. settlement records Detect breakage: missing ledger entries, duplicate entries, negative balances.\nProduction-Grade Guarantees Use:\nIdempotency keys on all mutating APIs Unique constraints on proposal references Immutable ledger (append-only, no updates) Versioned pricing models Event replay safety Avoid:\nUpdating ledger rows (ever) Coupling reporting DB to transactional DB Hardcoding commission logic Running reports on the operational database Architectural Observations Principle How It\u0026rsquo;s Achieved Separation of concerns Product config, transactions, ledger, and reporting are isolated bounded contexts Multi-LOB safe No LOB-specific tables — differences handled via JSON fields, cover types, and rule engine Regulatory ready Immutable ledger, audit log, versioned products, reserve tracking Partner scalable Override layer keeps partner customizations decoupled from base product Failure isolated Each subsystem can fail independently without corrupting financial state Event-driven extensibility Domain events decouple issuance from reporting, settlement, and notifications Closing Thought Embedded insurance is not just about attaching a plan to a checkout screen.\nIt is about building:\nA configurable product engine that supports multiple LOBs A reliable issuance pipeline with idempotency and failure recovery A financially correct ledger using double-entry accounting A scalable claims workflow with reserve tracking A compliant reporting backbone ready for regulatory scrutiny When designed properly, this becomes a reusable insurance infrastructure layer that can support multiple partners, multiple lines of business, multiple distribution models, high transaction scale, and strict regulatory requirements — all without rewriting the core.\n","permalink":"https://ankul01.github.io/profile/posts/tech-blogs/embedded-insurance/","summary":"A comprehensive architecture blueprint for building a production-grade embedded insurance platform — covering product configuration, issuance pipelines, double-entry ledgering, claims, and regulatory reporting.","title":"Designing an Embedded Insurance Platform"},{"content":"Engineering Leader | Bangalore, India\nEngineering leader with 14+ years of experience building and scaling low-latency, high-throughput platforms in fintech, insurance, and e-commerce. I lead organizations of 15+ engineers, owning mission-critical backend systems end-to-end — from architecture and design through production operations.\nMy work sits at the intersection of engineering depth and organizational leadership — architecting systems that handle 25K–30K+ RPM under strict correctness and regulatory constraints, while building teams and processes that deliver predictably in fast-moving environments.\nExperience Senior Engineering Manager — Acko General Insurance Oct 2025 – Present | Bangalore\nLead and grow a multi-layered engineering organization of 15+ engineers, including senior engineers and team leads, owning platforms across embedded insurance, lending, and partner integrations Own end-to-end lifecycle of highly scalable Java/Spring Boot microservices handling 30K+ RPM under strict regulatory and correctness constraints Architect and scale core platforms to reduce technical debt, improve performance, and support rapid onboarding of new business use cases without service disruption Lead by example through hands-on involvement in architecture reviews, critical backend components, and design decisions for high-throughput transactional systems Partner closely with Product, Business, and Compliance teams to translate complex requirements into reliable, production-grade systems delivered on predictable timelines Strengthen claims risk controls via ML-based fraud detection, improving detection accuracy by ~40% while reducing manual claim reviews Drive adoption of AI-assisted development workflows, reducing development cycle time by ~25% and improving sprint predictability Engineering Manager — Acko General Insurance Dec 2022 – Sep 2025 | Bangalore\nScaled embedded insurance platforms to 30K+ RPM, improving reliability, observability, and operational resilience Led zero-downtime migration of high-throughput issuance and claims systems (peaks ~2,000 policies/min) to a unified core platform — improving uptime by ~25% and scalability by ~30% Built a multi-brand dealer POS platform with real-time settlement, tax validation, and async reporting; onboarded 500+ dealers and enabled ~₹100 Cr annualized throughput Designed a reusable, standardized integration platform across multiple lines of business — reduced integration timelines by ~50% and improved engineering efficiency by ~40% Built self-service onboarding frameworks, cutting partner setup time from ~1 week to ~2 hours Established a new regulated Life Insurance LOB from scratch and delivered an industry-first hybrid insurance product Remained hands-on with critical backend components, design reviews, and architecture decisions Engineering Manager / Lead Software Engineer — Snapdeal Jan 2018 – Nov 2022 | Gurgaon\nLed checkout, payments, and order management platforms handling 25K+ RPM in high-traffic e-commerce environments Influenced product and system design for payments and post-order flows in collaboration with Product and Finance teams Designed and delivered a closed-wallet system for instant payments and refunds, integrating UPI and external wallet providers Built real-time refund and reconciliation systems, reducing settlement delays and improving financial accuracy Implemented secure payment gateway key management, strengthening compliance and security posture Software Developer → Senior Developer → Technical Lead — Nagarro Aug 2011 – Dec 2017 | Gurgaon\nBuilt scalable B2B e-commerce platforms, booking systems, and data pipelines across healthcare, gaming, and enterprise domains Partnered with stakeholders to translate business requirements into scalable technical designs Progressed from individual contributor to technical leadership, mentoring engineers and owning key system components Education Master of Computer Applications (MCA) National Institute of Technology, Tiruchirappalli | 2008 – 2011\nSkills \u0026amp; Expertise Leadership\nOrg design and team scaling (15+ engineers) Engineering strategy and execution Delivery predictability and Agile/Scrum Hiring, coaching, and stakeholder communication Technical\nJava, Spring Boot, AWS (EC2, S3, Lambda, RDS) Microservices, RESTful APIs, Kafka, MySQL Distributed systems, high-throughput transactional platforms AI \u0026amp; Automation\nAI-assisted development workflows Document intelligence and operational automation ML-based fraud detection and risk controls Get in Touch LinkedIn: linkedin.com/in/ankul-choudhry Email: ankulnitt@gmail.com GitHub: github.com/ankul01 ","permalink":"https://ankul01.github.io/profile/about/","summary":"About Ankul Choudhry","title":"About"}]